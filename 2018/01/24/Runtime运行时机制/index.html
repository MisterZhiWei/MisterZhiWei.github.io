<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Runtime运行时机制 | zwBlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="想深入理解Objective-C这门动态语言就不得不深入理解下它的“动态”是如何实现的。早先拜读过《Effective Objective-C 2.0》就让我更深入的窥探到OC运行时特别之处，本文当中也有部分内容借鉴自这本经典著作。第四届互联网大会的项目也完成了，年底闲来无事整理写些总结。 动态语言是相对于静态语言如C语言区别而言的。C语言在编译期就能决定了运行时应该调用的函数，函数地址实际上是硬">
<meta property="og:type" content="article">
<meta property="og:title" content="Runtime运行时机制">
<meta property="og:url" content="http://yoursite.com/2018/01/24/Runtime运行时机制/index.html">
<meta property="og:site_name" content="zwBlog">
<meta property="og:description" content="想深入理解Objective-C这门动态语言就不得不深入理解下它的“动态”是如何实现的。早先拜读过《Effective Objective-C 2.0》就让我更深入的窥探到OC运行时特别之处，本文当中也有部分内容借鉴自这本经典著作。第四届互联网大会的项目也完成了，年底闲来无事整理写些总结。 动态语言是相对于静态语言如C语言区别而言的。C语言在编译期就能决定了运行时应该调用的函数，函数地址实际上是硬">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/308319-1ad920412e90db1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-01-24T02:05:31.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Runtime运行时机制">
<meta name="twitter:description" content="想深入理解Objective-C这门动态语言就不得不深入理解下它的“动态”是如何实现的。早先拜读过《Effective Objective-C 2.0》就让我更深入的窥探到OC运行时特别之处，本文当中也有部分内容借鉴自这本经典著作。第四届互联网大会的项目也完成了，年底闲来无事整理写些总结。 动态语言是相对于静态语言如C语言区别而言的。C语言在编译期就能决定了运行时应该调用的函数，函数地址实际上是硬">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/308319-1ad920412e90db1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="zwBlog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">zwBlog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">我的心愿是...世界和平</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Runtime运行时机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/24/Runtime运行时机制/" class="article-date">
  <time datetime="2018-01-24T02:04:22.000Z" itemprop="datePublished">2018-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Runtime运行时机制
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>想深入理解Objective-C这门动态语言就不得不深入理解下它的“动态”是如何实现的。早先拜读过《Effective Objective-C 2.0》就让我更深入的窥探到OC运行时特别之处，本文当中也有部分内容借鉴自这本经典著作。第四届互联网大会的项目也完成了，年底闲来无事整理写些总结。</p>
<p>动态语言是相对于静态语言如C语言区别而言的。C语言在编译期就能决定了运行时应该调用的函数，函数地址实际上是硬编码在指令之中的。而OC在编译期甚至不知道对象的类型，需要在运行时处理，当然它的底层也都是转化为C函数调用。运行时实际上决定了OC最终的编程实现，即什么类的对象执行什么函数，而且这个执行调用是可以修改的，这也是运行时吸引人的地方。</p>
<p>运行时的调用有3种方式</p>
<ul>
<li>第一种是系统底层封装实现的，所有OC的代码就会调用，那就是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">id value = [someObj methodName:parameter];</span><br><span class="line">// 编译期OC转化为标准C函数</span><br><span class="line">id value = objc_msgSend(someObj,@selector(methodName:),parameter);</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plain"><figcaption><span>， ```objc_msgSend_stret```， ```objc_msgSendSuper```， ```objc_msgSendSuper_stret```，其他三种在处理一些“边界情况”的时候会用到，可查阅《Effective Objective-C 2.0》第45页，[这篇文章](https://www.cnblogs.com/ioshe/p/5489086.html)也有提及 ），它会根据对象即```someObj```和它的方法名来调用合适的方法完成完整的函数调用实现。在查询方法名时，它会首先在```someObj```的“方法列表”中查找，找不到就沿着它的继承体系向上找，如果都没有那就会看到调试时控制台提示的错误包含一句```[__ClassName  methodName] unrecognized selector sent to instance xxxx```，```someObj```所属的```__ClassName```类找不到```methodName ```这个对象方法，否则就可以正常运行了。如此看来，方法调用似乎每次都需要查表效率很低，其实不然，```objc_msgSend```会将匹配结果缓存到“快速映射表”（fast map）里，每个类都有这样一块缓存，下次再调用方法就直接可在映射表里找了。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 第二种是NSObjec这个基类特有的几个调用方法，能做类型判断或者查看是否有响应函数的这些方法都是运行时机制的方法。</span><br></pre></td></tr></table></figure>
<p>-class方法返回对象的类；<br>-isKindOfClass: 和 -isMemberOfClass: 方法检查对象是否存在于指定的类的继承体系中(是否是其子类或者父类或者当前类的成员变量)；<br>-respondsToSelector: 检查对象能否响应指定的消息；<br>-conformsToProtocol:检查对象是否实现了指定协议类的方法；<br>-methodForSelector: 返回指定方法实现的地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* 第三种就是直接调用Runtime函数库了，稍后在实际应用中会介绍到。</span><br><span class="line"></span><br><span class="line"># runtime可以做什么</span><br><span class="line">* 1. 动态方法添加</span><br><span class="line"></span><br><span class="line">如上所述，在开发中偶尔会有在消息转发过程中找不到调用方法而导致程序闪退，为了用户体验，闪退是不能允许的，所以我们需要利用运行时来杜绝因这个问题而导致的闪退，而转化为弹出其他报错提示，并把日志记录到后台中方便我们做进一步的程序完善。</span><br><span class="line"></span><br><span class="line">```[__ClassName  methodName] unrecognized selector sent to instance xxxx```这段异常信息是由```NSObject```的```doesNotRecognizeSelector:```方法所抛出的。但并不是拦截这个方法做处理防止闪退，因为这个方法只是帮助打印提示信息的。</span><br><span class="line"></span><br><span class="line">消息转发分为两个阶段，第一阶段是沿着继承体系查找是否能动态添加方法，以处理当前这个未知的方法，叫“动态方法解析”，第二阶段涉及“完整的消息转发机制”，如果第一阶段运行完，那方法接收者（如上边例子中的```someObj```）就无法再动态添加方法来响应这个找不到的方法了。此时运行时系统会请求接收者用其他手段来处理与消息有关的方法调用，这里又细分为2小步。首先请接收者看看有没有其他对象能处理这条消息，如果有，那么一切如常。若没有，则会启动完整的消息转发机制，运行时系统会把与消息有关的全部细节都封装到NSInvocation对象中（[NSInvocation的使用](http://blog.csdn.net/lcl130/article/details/41923711)），再给接收者最后一次机会，让它来设法解决这条消息。</span><br><span class="line"></span><br><span class="line">动态方法解析：</span><br><span class="line">在对象收到无法解读的消息后，首先将调用其所属类的下列类方法：</span><br><span class="line">```+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br></pre></td></tr></table></figure></p>
<p>该方法的参数就是那个未知的方法，其返回值<figure class="highlight plain"><figcaption><span>(BOOL)resolveClassMethod:(SEL)sel```这个方法了。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">```someObj```调用了未实现的实例方法```callMethod```,此时我们可以通过重载```+ (BOOL)resolveInstanceMethod:(SEL)sel```来处理这个未知方法。</span><br></pre></td></tr></table></figure></p>
<ul>
<li>(BOOL)resolveInstanceMethod:(SEL)sel{<br>if (sel == NSSelectorFromString(@”callMethod”)) {<br>/*</li>
</ul>
<ul>
<li>IMP 是编译期生成的函数指针</li>
<li>class_addMethod 函数完成向特定类添加特定方法实现的操作<br>*/<br>class_addMethod(self,sel,(IMP)callMethodTest,”chart”);<br>return YES;<br>}</li>
</ul>
<p>return [super resolveClassMethod:sel];<br>}</p>
<p>void callMethodTest (id self ,SEL _cmd){<br>NSLog(@”—callMethodTest—-“);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这种处理方式也常用来处理```@dynamic```修饰的属性，因为使用```@dynamic```就是告诉编译器，不要自动创建实现属性所用的实例变量，也不要为其创建存取方法，我们会为这个属性动态提供存取方法。</span><br><span class="line"></span><br><span class="line">注意：我们并不能重载```+ (BOOL)resolveInstanceMethod:(SEL)sel```使返回值直接为```YES```,这样会让我们不知道哪里出了问题，因为我们不能通过```SEL```来获取方法信息。</span><br><span class="line"></span><br><span class="line">* 2.动态添加属性和判断属性类型</span><br><span class="line"></span><br><span class="line">动态添加属性：</span><br><span class="line">一般来说分类（category）中是不支持添加属性的，但有时候确实需要添加，那么就可以通过 ```objc/runtime.h``` 库中的一些函数来实现。在```AFNetworking```、```Masonry```、```SDWebImage```等常用框架中都大量用到了这种方式。</span><br><span class="line">栗子：</span><br></pre></td></tr></table></figure></p>
<p>#import <foundation foundation.h=""></foundation></p>
<p>@interface NSObject (ExchangeMethod)</p>
<p>@property (strong, nonatomic) NSString *name;</p>
<p>@end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>#import “NSObject+ExchangeMethod.h”</p>
<p>#import <objc runtime.h=""></objc></p>
<p>#define NameKey @”nameKey”</p>
<p>@implementation NSObject (ExchangeMethod)</p>
<ul>
<li><p>(void)setName:(NSString *)name{<br>// 将属性同对象关联<br>objc_setAssociatedObject(self, NameKey, name, OBJC_ASSOCIATION_COPY_NONATOMIC);<br>}</p>
</li>
<li><p>(NSString *)name{<br>// 取出 对应Key关联的对象属性<br>return objc_getAssociatedObject(self, NameKey);<br>}</p>
</li>
</ul>
<p>@end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">属性类型判断：</span><br><span class="line">类型判断常见的使用场景就是数据解析--字典转模型。</span><br><span class="line">获取属性列表的方式有两种：</span><br></pre></td></tr></table></figure></p>
<p>// 第一种<br>unsigned int count;</p>
<p>objc_property_t *properties = class_copyPropertyList(self.class, &amp;count);</p>
<p>NSMutableArray *array = [NSMutableArray array];</p>
<p>for (int i =0; i&lt; count ; i++) {<br>objc_property_t pro = properties[I];<br>const char <em>name = property_getName(pro);<br>const char </em>attributes = property_getAttributes(pro);<br>NSString *property = [[NSString alloc] initWithUTF8String:name];<br>[array addObject:property];<br>NSLog(@”attributes : %s,  name: %s”,attributes,name);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>// 第二种<br>unsigned int count;<br>/<em>
</em>参数1：类名<br><em>参数2：传入无符号整型的内存地址，当读取到成员变量的数量时，会给这个值赋值
</em>返回值：Ivar <em> ：是一个指针类型，相当于数组，里边装着Ivar
</em>/</p>
<p>Ivar *ivars = class_copyIvarList([UIView class],&amp;count);</p>
<p>for (int i=0; i &lt; count; i++) {<br>Ivar ivar = ivars[I];<br>// 获取属性名字，调用函数ivar_getName(ivar)获取<br>NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)];</p>
<p>// 获取属性类型，调用函数ivar_getTypeEncoding(ivar)获取<br>NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];<br>NSLog(@”type : %@,  name: %@”,type,name);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>/// An opaque type that represents an instance variable.<br>/<em><br>Ivar 是表示成员变量的类型
</em>/<br>typedef struct objc_ivar *<img src="http://upload-images.jianshu.io/upload_images/308319-1ad920412e90db1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Ivar.png"><br>;</p>
<p>/// An opaque type that represents an Objective-C declared property.<br>/<em><br>objc_property_t 是表示一个Objective-C声明的属性
</em>/<br>typedef struct objc_property * objc_property_t;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">两者都可以获取属性名称和类型，信息详细程度不一样。</span><br><span class="line"></span><br><span class="line">![Ivar.png](http://upload-images.jianshu.io/upload_images/308319-7c6655e04b10d3ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">![objc_property_t.png](http://upload-images.jianshu.io/upload_images/308319-9982b9792794e9b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">```objc_property_t```打印的属性的特性字符串说明，通过```property_getAttributes(objc_property_t _Nonnull property) ```获取查看</span><br></pre></td></tr></table></figure></p>
<p>//特性<br>typedef struct {<br>const char <em>name;           //特性名称<br>const char </em>value;          //特性的值<br>} objc_property_attribute_t;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">特性编码 具体含义</span><br></pre></td></tr></table></figure></p>
<p>R readonly<br>C copy<br>&amp; retain<br>N nonatomic<br>G(name) getter=(name)<br>S(name) setter=(name)<br>D @dynamic<br>W weak<br>P 用于垃圾回收机制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[详细参见](http://www.jianshu.com/p/ead476cdb828)</span><br><span class="line">一般获取属性信息用第一种，YYModel和MJExtension 框架中都有用到。</span><br><span class="line"></span><br><span class="line">* 3.方法交换</span><br><span class="line">OC对象在收到消息后，究竟调用哪种方法是在运行时才能解析决定的。而在运行时我们还可以新增、修改或者交换执行方法，也叫“方法调配”即```method swizzling```。</span><br><span class="line"></span><br><span class="line">类的“方法列表”中会把方法名映射到相关的方法实现上，通过“动态消息派发系统”找到对应的调用方法。这些方法均已函数指针的形式来表示，即```IMP```。比如：```someObj```对象可以响应```makeName```、```makeHeight```、```makeSex```等方法，这张表中的每个方法都映射到不同的IMP上，如下图。</span><br><span class="line"></span><br><span class="line">![someObj对象的方法映射表.png](http://upload-images.jianshu.io/upload_images/308319-bccb3f7467fc0ade.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">OC在运行时系统提供的几个API能用来操作这张表。</span><br><span class="line">```method_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2)```可以用来做方法交换。</span><br></pre></td></tr></table></figure></p>
<p>+(void)load{<br>Method m1 = class_getInstanceMethod(self, NSSelectorFromString(@”makeName”));<br>Method m2 = class_getInstanceMethod(self, @selector(testMakeName));</p>
<p>method_exchangeImplementations(m1, m2);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不过，在实际开发中，直接交换方法的意义并不大，每一个方法都应该对应自己的实现。但是，为既有方法添加新功能是比较实用的。</span><br><span class="line">栗子：</span><br><span class="line">```NSString```的获取小写字符串方法```lowercaseString```，我们要打印信息，那我们可以这样写</span><br></pre></td></tr></table></figure></p>
<p>+(void)load{<br>Method m1 = class_getInstanceMethod(self, NSSelectorFromString(@”lowercaseString”));<br>Method m2 = class_getInstanceMethod(self, @selector(mcLowercaseString));</p>
<p>method_exchangeImplementations(m1, m2);<br>}</p>
<ul>
<li>(NSString <em>)mcLowercaseString{<br>NSString </em>lowercase = [self mcLowercaseString];<br>NSLog(@”%@ =&gt; %@”,self,lowercase);<br>return lowercase;<br>}<br><code>这段代码看似会死循环，其实不然，因为两个方法名指向了对方的函数指针IMP，所以</code> [self mcLowercaseString];<code>实际上是调用的</code>lowercaseString```。通过这种方式，我们可以为那些系统黑盒方法增加日志打印功能，非常有助于调试使用。一般很少有人用这个特性永久修改某各类的功能，而且若滥用的话，反而会让代码不易读难于维护。</li>
</ul>
<p>关于分类category美团技术博客也有一篇<a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">点击查看</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/24/Runtime运行时机制/" data-id="cjcsfi7040000jhfymx96wpyy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/24/Runtime运行时机制/">Runtime运行时机制</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 ZhiWei<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>