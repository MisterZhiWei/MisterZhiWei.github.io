<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Runtime运行时机制 | zwBlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="想深入理解Objective-C这门动态语言就不得不深入理解下它的“动态”是如何实现的。早先拜读过《Effective Objective-C 2.0》就让我更深入的窥探到OC运行时特别之处，本文当中也有部分内容借鉴自这本经典著作。第四届互联网大会的项目也完成了，年底闲来无事整理写些总结。 动态语言是相对于静态语言如C语言区别而言的。C语言在编译期就能决定了运行时应该调用的函数，函数地址实际上是硬">
<meta property="og:type" content="article">
<meta property="og:title" content="Runtime运行时机制">
<meta property="og:url" content="http://yoursite.com/2018/01/24/Runtime运行时机制/index.html">
<meta property="og:site_name" content="zwBlog">
<meta property="og:description" content="想深入理解Objective-C这门动态语言就不得不深入理解下它的“动态”是如何实现的。早先拜读过《Effective Objective-C 2.0》就让我更深入的窥探到OC运行时特别之处，本文当中也有部分内容借鉴自这本经典著作。第四届互联网大会的项目也完成了，年底闲来无事整理写些总结。 动态语言是相对于静态语言如C语言区别而言的。C语言在编译期就能决定了运行时应该调用的函数，函数地址实际上是硬">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/308319-7c6655e04b10d3ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/308319-9982b9792794e9b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/308319-bccb3f7467fc0ade.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-01-24T02:17:01.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Runtime运行时机制">
<meta name="twitter:description" content="想深入理解Objective-C这门动态语言就不得不深入理解下它的“动态”是如何实现的。早先拜读过《Effective Objective-C 2.0》就让我更深入的窥探到OC运行时特别之处，本文当中也有部分内容借鉴自这本经典著作。第四届互联网大会的项目也完成了，年底闲来无事整理写些总结。 动态语言是相对于静态语言如C语言区别而言的。C语言在编译期就能决定了运行时应该调用的函数，函数地址实际上是硬">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/308319-7c6655e04b10d3ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="zwBlog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">zwBlog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">我的心愿是...世界和平</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Runtime运行时机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/24/Runtime运行时机制/" class="article-date">
  <time datetime="2018-01-24T02:04:22.000Z" itemprop="datePublished">2018-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Runtime运行时机制
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>想深入理解Objective-C这门动态语言就不得不深入理解下它的“动态”是如何实现的。早先拜读过《Effective Objective-C 2.0》就让我更深入的窥探到OC运行时特别之处，本文当中也有部分内容借鉴自这本经典著作。第四届互联网大会的项目也完成了，年底闲来无事整理写些总结。</p>
<p>动态语言是相对于静态语言如C语言区别而言的。C语言在编译期就能决定了运行时应该调用的函数，函数地址实际上是硬编码在指令之中的。而OC在编译期甚至不知道对象的类型，需要在运行时处理，当然它的底层也都是转化为C函数调用。运行时实际上决定了OC最终的编程实现，即什么类的对象执行什么函数，而且这个执行调用是可以修改的，这也是运行时吸引人的地方。</p>
<p>运行时的调用有3种方式</p>
<ul>
<li>第一种是系统底层封装实现的，所有OC的代码就会调用，那就是<code>消息传递</code>机制。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id value = [someObj methodName:parameter];</span><br><span class="line">// 编译期OC转化为标准C函数</span><br><span class="line">id value = objc_msgSend(someObj,@selector(methodName:),parameter);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>objc_msgSend</code>是<code>消息传递</code>机制中的核心函数（实际上是四种<code>objc_msgSend</code> ， <code>objc_msgSend_stret</code>， <code>objc_msgSendSuper</code>， <code>objc_msgSendSuper_stret</code>，其他三种在处理一些“边界情况”的时候会用到，可查阅《Effective Objective-C 2.0》第45页，<a href="https://www.cnblogs.com/ioshe/p/5489086.html" target="_blank" rel="noopener">这篇文章</a>也有提及 ），它会根据对象即<code>someObj</code>和它的方法名来调用合适的方法完成完整的函数调用实现。在查询方法名时，它会首先在<code>someObj</code>的“方法列表”中查找，找不到就沿着它的继承体系向上找，如果都没有那就会看到调试时控制台提示的错误包含一句<code>[__ClassName  methodName] unrecognized selector sent to instance xxxx</code>，<code>someObj</code>所属的<code>__ClassName</code>类找不到<code>methodName</code>这个对象方法，否则就可以正常运行了。如此看来，方法调用似乎每次都需要查表效率很低，其实不然，<code>objc_msgSend</code>会将匹配结果缓存到“快速映射表”（fast map）里，每个类都有这样一块缓存，下次再调用方法就直接可在映射表里找了。</p>
<ul>
<li><p>第二种是NSObjec这个基类特有的几个调用方法，能做类型判断或者查看是否有响应函数的这些方法都是运行时机制的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-class方法返回对象的类；</span><br><span class="line">-isKindOfClass: 和 -isMemberOfClass: 方法检查对象是否存在于指定的类的继承体系中(是否是其子类或者父类或者当前类的成员变量)；</span><br><span class="line">-respondsToSelector: 检查对象能否响应指定的消息；</span><br><span class="line">-conformsToProtocol:检查对象是否实现了指定协议类的方法；</span><br><span class="line">-methodForSelector: 返回指定方法实现的地址。</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三种就是直接调用Runtime函数库了，稍后在实际应用中会介绍到。</p>
</li>
</ul>
<h1 id="runtime可以做什么"><a href="#runtime可以做什么" class="headerlink" title="runtime可以做什么"></a>runtime可以做什么</h1><ul>
<li><ol>
<li>动态方法添加</li>
</ol>
</li>
</ul>
<p>如上所述，在开发中偶尔会有在消息转发过程中找不到调用方法而导致程序闪退，为了用户体验，闪退是不能允许的，所以我们需要利用运行时来杜绝因这个问题而导致的闪退，而转化为弹出其他报错提示，并把日志记录到后台中方便我们做进一步的程序完善。</p>
<p><code>[__ClassName  methodName] unrecognized selector sent to instance xxxx</code>这段异常信息是由<code>NSObject</code>的<code>doesNotRecognizeSelector:</code>方法所抛出的。但并不是拦截这个方法做处理防止闪退，因为这个方法只是帮助打印提示信息的。</p>
<p>消息转发分为两个阶段，第一阶段是沿着继承体系查找是否能动态添加方法，以处理当前这个未知的方法，叫“动态方法解析”，第二阶段涉及“完整的消息转发机制”，如果第一阶段运行完，那方法接收者（如上边例子中的<code>someObj</code>）就无法再动态添加方法来响应这个找不到的方法了。此时运行时系统会请求接收者用其他手段来处理与消息有关的方法调用，这里又细分为2小步。首先请接收者看看有没有其他对象能处理这条消息，如果有，那么一切如常。若没有，则会启动完整的消息转发机制，运行时系统会把与消息有关的全部细节都封装到NSInvocation对象中（<a href="http://blog.csdn.net/lcl130/article/details/41923711" target="_blank" rel="noopener">NSInvocation的使用</a>），再给接收者最后一次机会，让它来设法解决这条消息。</p>
<p>动态方法解析：<br>在对象收到无法解读的消息后，首先将调用其所属类的下列类方法：<br><code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code><br>该方法的参数就是那个未知的方法，其返回值<code>Boolean</code>类型，表示这个类是否能新增一个实例方法类处理这个方法。如果未知的方法不是对象方法而是类方法，那么调用的就是<code>+ (BOOL)resolveClassMethod:(SEL)sel</code>这个方法了。<br>例如：<br><code>someObj</code>调用了未实现的实例方法<code>callMethod</code>,此时我们可以通过重载<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>来处理这个未知方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">if (sel == NSSelectorFromString(@&quot;callMethod&quot;)) &#123;</span><br><span class="line">/*</span><br><span class="line">* IMP 是编译期生成的函数指针</span><br><span class="line">* class_addMethod 函数完成向特定类添加特定方法实现的操作</span><br><span class="line">*/</span><br><span class="line">class_addMethod(self,sel,(IMP)callMethodTest,&quot;chart&quot;);</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return [super resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void callMethodTest (id self ,SEL _cmd)&#123;</span><br><span class="line">NSLog(@&quot;---callMethodTest----&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种处理方式也常用来处理<code>@dynamic</code>修饰的属性，因为使用<code>@dynamic</code>就是告诉编译器，不要自动创建实现属性所用的实例变量，也不要为其创建存取方法，我们会为这个属性动态提供存取方法。</p>
<p>注意：我们并不能重载<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>使返回值直接为<code>YES</code>,这样会让我们不知道哪里出了问题，因为我们不能通过<code>SEL</code>来获取方法信息。</p>
<ul>
<li>2.动态添加属性和判断属性类型</li>
</ul>
<p>动态添加属性：<br>一般来说分类（category）中是不支持添加属性的，但有时候确实需要添加，那么就可以通过 <code>objc/runtime.h</code> 库中的一些函数来实现。在<code>AFNetworking</code>、<code>Masonry</code>、<code>SDWebImage</code>等常用框架中都大量用到了这种方式。<br>栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface NSObject (ExchangeMethod)</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NSObject+ExchangeMethod.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">#define NameKey @&quot;nameKey&quot;</span><br><span class="line"></span><br><span class="line">@implementation NSObject (ExchangeMethod)</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name&#123;</span><br><span class="line">// 将属性同对象关联</span><br><span class="line">objc_setAssociatedObject(self, NameKey, name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)name&#123;</span><br><span class="line">// 取出 对应Key关联的对象属性</span><br><span class="line">return objc_getAssociatedObject(self, NameKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>属性类型判断：<br>类型判断常见的使用场景就是数据解析–字典转模型。<br>获取属性列表的方式有两种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 第一种</span><br><span class="line">unsigned int count;</span><br><span class="line"></span><br><span class="line">objc_property_t *properties = class_copyPropertyList(self.class, &amp;count);</span><br><span class="line"></span><br><span class="line">NSMutableArray *array = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">for (int i =0; i&lt; count ; i++) &#123;</span><br><span class="line">objc_property_t pro = properties[I];</span><br><span class="line">const char *name = property_getName(pro);</span><br><span class="line">const char *attributes = property_getAttributes(pro);</span><br><span class="line">NSString *property = [[NSString alloc] initWithUTF8String:name];</span><br><span class="line">[array addObject:property];</span><br><span class="line">NSLog(@&quot;attributes : %s,  name: %s&quot;,attributes,name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 第二种</span><br><span class="line">unsigned int count;</span><br><span class="line">/*</span><br><span class="line">*参数1：类名</span><br><span class="line">*参数2：传入无符号整型的内存地址，当读取到成员变量的数量时，会给这个值赋值</span><br><span class="line">*返回值：Ivar * ：是一个指针类型，相当于数组，里边装着Ivar</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">Ivar *ivars = class_copyIvarList([UIView class],&amp;count);</span><br><span class="line"></span><br><span class="line">for (int i=0; i &lt; count; i++) &#123;</span><br><span class="line">Ivar ivar = ivars[I];</span><br><span class="line">// 获取属性名字，调用函数ivar_getName(ivar)获取</span><br><span class="line">NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line"></span><br><span class="line">// 获取属性类型，调用函数ivar_getTypeEncoding(ivar)获取</span><br><span class="line">NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];</span><br><span class="line">NSLog(@&quot;type : %@,  name: %@&quot;,type,name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents an instance variable.</span><br><span class="line">/*</span><br><span class="line">Ivar 是表示成员变量的类型</span><br><span class="line">*/</span><br><span class="line">typedef struct objc_ivar *![Ivar.png](http://upload-images.jianshu.io/upload_images/308319-1ad920412e90db1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">/// An opaque type that represents an Objective-C declared property.</span><br><span class="line">/*</span><br><span class="line">objc_property_t 是表示一个Objective-C声明的属性</span><br><span class="line">*/</span><br><span class="line">typedef struct objc_property * objc_property_t;</span><br></pre></td></tr></table></figure>
<p>两者都可以获取属性名称和类型，信息详细程度不一样。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/308319-7c6655e04b10d3ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Ivar.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/308319-9982b9792794e9b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="objc_property_t.png"></p>
<p><code>objc_property_t</code>打印的属性的特性字符串说明，通过<code>property_getAttributes(objc_property_t _Nonnull property)</code>获取查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//特性</span><br><span class="line">typedef struct &#123;</span><br><span class="line">const char *name;           //特性名称</span><br><span class="line">const char *value;          //特性的值</span><br><span class="line">&#125; objc_property_attribute_t;</span><br></pre></td></tr></table></figure></p>
<p>特性编码 具体含义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">R readonly</span><br><span class="line">C copy</span><br><span class="line">&amp; retain</span><br><span class="line">N nonatomic</span><br><span class="line">G(name) getter=(name)</span><br><span class="line">S(name) setter=(name)</span><br><span class="line">D @dynamic</span><br><span class="line">W weak</span><br><span class="line">P 用于垃圾回收机制</span><br></pre></td></tr></table></figure></p>
<p><a href="http://www.jianshu.com/p/ead476cdb828" target="_blank" rel="noopener">详细参见</a><br>一般获取属性信息用第一种，YYModel和MJExtension 框架中都有用到。</p>
<ul>
<li>3.方法交换<br>OC对象在收到消息后，究竟调用哪种方法是在运行时才能解析决定的。而在运行时我们还可以新增、修改或者交换执行方法，也叫“方法调配”即<code>method swizzling</code>。</li>
</ul>
<p>类的“方法列表”中会把方法名映射到相关的方法实现上，通过“动态消息派发系统”找到对应的调用方法。这些方法均已函数指针的形式来表示，即<code>IMP</code>。比如：<code>someObj</code>对象可以响应<code>makeName</code>、<code>makeHeight</code>、<code>makeSex</code>等方法，这张表中的每个方法都映射到不同的IMP上，如下图。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/308319-bccb3f7467fc0ade.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="someObj对象的方法映射表.png"></p>
<p>OC在运行时系统提供的几个API能用来操作这张表。<br><code>method_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2)</code>可以用来做方法交换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+(void)load&#123;</span><br><span class="line">Method m1 = class_getInstanceMethod(self, NSSelectorFromString(@&quot;makeName&quot;));</span><br><span class="line">Method m2 = class_getInstanceMethod(self, @selector(testMakeName));</span><br><span class="line"></span><br><span class="line">method_exchangeImplementations(m1, m2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过，在实际开发中，直接交换方法的意义并不大，每一个方法都应该对应自己的实现。但是，为既有方法添加新功能是比较实用的。<br>栗子：<br><code>NSString</code>的获取小写字符串方法<code>lowercaseString</code>，我们要打印信息，那我们可以这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+(void)load&#123;</span><br><span class="line">Method m1 = class_getInstanceMethod(self, NSSelectorFromString(@&quot;lowercaseString&quot;));</span><br><span class="line">Method m2 = class_getInstanceMethod(self, @selector(mcLowercaseString));</span><br><span class="line"></span><br><span class="line">method_exchangeImplementations(m1, m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)mcLowercaseString&#123;</span><br><span class="line">NSString *lowercase = [self mcLowercaseString];</span><br><span class="line">NSLog(@&quot;%@ =&gt; %@&quot;,self,lowercase);</span><br><span class="line">return lowercase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码看似会死循环，其实不然，因为两个方法名指向了对方的函数指针IMP，所以<code>[self mcLowercaseString];</code>实际上是调用的<code>lowercaseString</code>。通过这种方式，我们可以为那些系统黑盒方法增加日志打印功能，非常有助于调试使用。一般很少有人用这个特性永久修改某各类的功能，而且若滥用的话，反而会让代码不易读难于维护。</p>
<p>关于分类category美团技术博客也有一篇<a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">点击查看</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/24/Runtime运行时机制/" data-id="cjcsg49k20000opfyc6dq5c8j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/06/25/iOS开发-关于苹果健康数据的获取/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">iOS开发-关于苹果健康数据的获取</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/24/Runtime运行时机制/">Runtime运行时机制</a>
          </li>
        
          <li>
            <a href="/2016/06/25/iOS开发-关于苹果健康数据的获取/">iOS开发-关于苹果健康数据的获取</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 ZhiWei<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>