<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="iOS开发,多线程," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="iOS多线程开发必须知道的概念名词：1. 进程 进程（process）就是一个正在执行的程序的实例。也就是说我们的每一个APP程序在执行时实例都是一个进程，也可以说在APP执行时，它只拥有唯一的一个进程。 每一个进程都是独立的，每一个进程均在专属的内存空间内，iOS中每一个App（一个进程）都有自己独特的内存和磁盘空间，别的App（进程）是不允许访问的（越狱除外）。iOS开发中应用程序之间互相调用">
<meta name="keywords" content="iOS开发,多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS开发多线程-NSOperation  GCD详解">
<meta property="og:url" content="http://yoursite.com/2017/12/25/iOS开发多线程-NSOperation-GCD详解/index.html">
<meta property="og:site_name" content="zwBlog">
<meta property="og:description" content="iOS多线程开发必须知道的概念名词：1. 进程 进程（process）就是一个正在执行的程序的实例。也就是说我们的每一个APP程序在执行时实例都是一个进程，也可以说在APP执行时，它只拥有唯一的一个进程。 每一个进程都是独立的，每一个进程均在专属的内存空间内，iOS中每一个App（一个进程）都有自己独特的内存和磁盘空间，别的App（进程）是不允许访问的（越狱除外）。iOS开发中应用程序之间互相调用">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/308319-4ae3d78e6eab6892.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/308319-edc3a36a5087fb4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/308319-b48a0a22d2f7000d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-06-04T01:17:11.563Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS开发多线程-NSOperation  GCD详解">
<meta name="twitter:description" content="iOS多线程开发必须知道的概念名词：1. 进程 进程（process）就是一个正在执行的程序的实例。也就是说我们的每一个APP程序在执行时实例都是一个进程，也可以说在APP执行时，它只拥有唯一的一个进程。 每一个进程都是独立的，每一个进程均在专属的内存空间内，iOS中每一个App（一个进程）都有自己独特的内存和磁盘空间，别的App（进程）是不允许访问的（越狱除外）。iOS开发中应用程序之间互相调用">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/308319-4ae3d78e6eab6892.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/12/25/iOS开发多线程-NSOperation-GCD详解/"/>





  <title>iOS开发多线程-NSOperation  GCD详解 | zwBlog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?926d5bc189fa5fc245e426f70c23b8fd";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zwBlog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我的心愿是...世界和平</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/25/iOS开发多线程-NSOperation-GCD详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhiWei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/img/icon.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zwBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS开发多线程-NSOperation  GCD详解</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-25T10:26:32+08:00">
                2017-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h5 id="iOS多线程开发必须知道的概念名词："><a href="#iOS多线程开发必须知道的概念名词：" class="headerlink" title="iOS多线程开发必须知道的概念名词："></a>iOS多线程开发必须知道的概念名词：</h5><h5 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h5><ul>
<li>进程（process）就是一个正在执行的程序的实例。也就是说我们的每一个APP程序在执行时实例都是一个进程，也可以说在APP执行时，它只拥有唯一的一个进程。</li>
<li>每一个进程都是独立的，每一个进程均在专属的内存空间内，iOS中每一个App（一个进程）都有自己独特的内存和磁盘空间，别的App（进程）是不允许访问的（越狱除外）。iOS开发中应用程序之间互相调用包括调用发短信、打电话等进程相关操作的API都被封装到<code>UIApplication</code>这个类中了。</li>
<li>每个进程至少拥有一个线程。</li>
<li>在UNIX和Linux系统中是有进程层次结构的，当进程创建了另一个进程后，父进程和子进程就以某种方式继续保持联系。子进程自身可以创建更多的进程，组成一个进程的层次结构。（进程只有一个父进程但是可以有0个，1个或多个子进程。）而Windows中没有进程层次的概念，所有进程地位相同。唯一类似进程层次的地方是在创建进程的时候父进程得到一个特别的令牌（称为句柄），该令牌可以用来控制子进程。但是父进程可以把这个令牌传送给其他进程，这样就不存在进程层次了。</li>
<li>进程有3种状态，分别是：<br>1）运行态（该时刻进程实际占用CPU）。<br>2）就绪态（可运行，但因为其他进程正在运行而暂时停止）。<br>3）阻塞态（除非某种外部事件发生，否则进程不能运行）。<a id="more"></a>
<h5 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h5></li>
<li>进程用于把资源集中到一起，而线程是在CUP上被调度的实体。</li>
<li>线程拥有自己的寄存器，用来保存当前的工作变量，称作线程的上下文。还拥有一个自己的堆栈，用来记录执行历史。</li>
<li>线程之间共享同样的内存空间和全局变量，一个线程可以读、写或甚至清除另一个线程的堆栈。</li>
<li>如果多个线程都是CPU密集型（也称计算密集型）那并不能获得性能上的增强，如果是I/O密集型则能加快程序执行速度。</li>
</ul>
<h5 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h5><ul>
<li>线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，它们共享进程的地址空间。一个线程crash就等于整个进程crash。</li>
<li>进程的创建和操作开销很大，某种意义上讲线程就相当于轻量级的进程。多线程使用的其中一个理由就是因为线程比进程更轻量级，线程比进程更容易（即更快）的创建和撤销。在许多系统中，创建一个线程比创建一个进程要快10~100倍。<br><img src="http://upload-images.jianshu.io/upload_images/308319-4ae3d78e6eab6892.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="进程线程关系示意图.jpeg"></li>
</ul>
<blockquote>
<p>多线程（英语：multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。</p>
</blockquote>
<p>多线程好处多的同时也易引发一些问题，“数据竞争”-多个线程操作同一资源时可能会导致数据的不一致；“死锁”-两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象；使用太多的线程会消耗大量内存，因为每个线程都有自己的寄存器。进程太多的时候也有消耗太大的问题。</p>
<h5 id="3-串行（serial）-amp-并发（concurrent）-amp-并行"><a href="#3-串行（serial）-amp-并发（concurrent）-amp-并行" class="headerlink" title="3.  串行（serial） &amp;  并发（concurrent）&amp; 并行"></a>3.  串行（serial） &amp;  并发（concurrent）&amp; 并行</h5><p><code>串行</code>是同步线程的实现方式，就是任务A执行结束才能开始执行B，单个线程只能执行一个任务。<br><code>并发</code>和<code>并行</code>其实是异步线程实现的两种形式。<code>并行</code>其实是真正的异步，多核CUP可以同时开启多条线程供多个任务同时执行,互不干扰。<code>并发</code>是伪异步，单个CUP一个时刻只能有一个线程执行，想执行多个任务就必须不断切换执行任务的线程。</p>
<h5 id="4-同步-amp-异步"><a href="#4-同步-amp-异步" class="headerlink" title="4. 同步 &amp; 异步"></a>4. 同步 &amp; 异步</h5><p><code>同步</code>:多个任务情况下，一个任务A执行结束，才可以执行另一个任务B。只存在一个线程。<br><code>异步</code>:多个任务情况下，一个任务A正在执行，同时可以执行另一个任务B。任务B不用等待任务A结束才执行。存在多条线程。</p>
<h5 id="5-调度队列（Dispatch-Queue）"><a href="#5-调度队列（Dispatch-Queue）" class="headerlink" title="5. 调度队列（Dispatch Queue）"></a>5. 调度队列（Dispatch Queue）</h5><p><code>调度队列</code>是执行处理的队列也是GCD的基本概念，它按照执行任务添加的顺序（即FIFO-先进先出顺序）执行处理。<code>调度队列</code>在执行处理时存在两种Dispatch Queue，一种是等待现在执行中处理的<code>Serial Dispatch Queue</code>,另一种是不等待现在执行中处理的<code>Concurrent Dispatch Queue</code>，稍后会对这两种队列详细的介绍。官方的说法是有三种队列，还要一种叫<code>Main dispatch queue</code>，<code>Main dispatch queue</code>其实也可以归为<code>Serial Dispatch Queue</code>，不过由于它是主线程队列所以单拿了出来。</p>
<h1 id="iOS多线程技术对比"><a href="#iOS多线程技术对比" class="headerlink" title="iOS多线程技术对比"></a>iOS多线程技术对比</h1><ul>
<li><h3 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h3><code>pthread（POSIX thread）</code>是一套通用的多线程API，适用于Unix、Linux、Windows等系统，跨平台、可移植的C语言框架，线程生命周期由开发者管理，使用难度大。GCD的底层实现库中也有用到<code>Libc(pthreads)</code>。</li>
</ul>
<ul>
<li><h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><code>NSThread</code>是这几种方法里面相对轻量级的，但需要管理线程的生命周期、同步、加锁问题，这会导致一定的性能开销，同时在多个线程开发时不便于开发维护。详细使用可参考<a href="http://www.jianshu.com/p/0d4812426f72" target="_blank" rel="noopener">这篇博客</a>。</li>
</ul>
<ul>
<li><h3 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h3></li>
<li><code>NSOperation</code>是基于OC实现的，它以面向对象的方式封装了需要执行的操作，然后可以将这个操作放到一个<code>NSOperationQueue</code>中去异步执行。它是线程安全的，开发者不必关心线程管理、同步等问题。</li>
<li><code>NSOperation</code>类是一个抽象类来封装一个任务相关的代码和数据，不能直接被使用。可以使用它的两个子类<br><code>NSInvocationOperation</code>或<code>NSBlockoperation</code>来执行实际的任务，当然你也可以自己封装一个子类来实现（只需要重载<code>-(void)main</code>这个方法，在这个方法里面添加需要执行的操作。）。</li>
<li><code>NSOperation</code>可以取消添加的执行任务。一个<code>NSOperation</code>对象是一个单次对象（single-shot object）只能执行一次任务，不能再次执行它。</li>
</ul>
<ul>
<li><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3></li>
<li><code>Grand Central Dispatch（GCD）</code>是苹果开发的基于XNU内核级线程管理技术，优化对多核处理器的支持。</li>
<li>GCD是一个基于线程池的任务并行执行模式。其基本思想是将线程池的管理从开发人员手中转移出来，并更接近操作系统（更高效）。开发人员不用管理线程，只需要把任务添加到执行队列就可以。</li>
<li>GCD基于C语言实现，不过使用了Block，因而API非常简洁易用。</li>
<li>GCD需要开发者释放自己创建的队列<code>Dispatch Queue</code>，系统提供的标准队列是全局的所以不用释放。</li>
</ul>
<h1 id="NSOperation-1"><a href="#NSOperation-1" class="headerlink" title="NSOperation"></a>NSOperation</h1><p><code>NSOperation</code>实现多线程主要步骤是:<br>1&gt; 封装执行的操作到一个<code>NSOperation</code>对象中</p>
<p>2&gt; 将封装的<code>NSOperation</code>对象添加到<code>NSOperationQueue</code>中</p>
<p>3&gt; 系统会自动为<code>NSOperation</code>对象封装的任务开启一条线程执行 或者 不加入队列调用<code>-(void)start:</code>在主线程执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)operationManage&#123;</span><br><span class="line">// 这样在主线程执行其实是画蛇添足的，只是为了做说明而写</span><br><span class="line">NSBlockOperation *downloadImgPng = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">//downloadImage 任务</span><br><span class="line">NSLog(@&quot;png -- 当前线程%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">[downloadImgPng start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//  NSInvocationOperation执行方式</span><br><span class="line">- (void)operationManage&#123;</span><br><span class="line">NSInvocationOperation *invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(downloadImage) object:nil];</span><br><span class="line"></span><br><span class="line">NSOperationQueue *operationQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">// 同一时间最多开启的线程数</span><br><span class="line">operationQueue.maxConcurrentOperationCount = 6;</span><br><span class="line">[operationQueue addOperation:invocationOperation];</span><br><span class="line"></span><br><span class="line">// 取消所有队列中的任务</span><br><span class="line">//    [operationQueue cancelAllOperations];</span><br><span class="line"></span><br><span class="line">// 取消执行的任务</span><br><span class="line">//    [invocationOperation cancel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)downloadImage&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//  NSBlockOperation执行方式</span><br><span class="line">- (void)operationManage&#123;</span><br><span class="line">NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">//downloadImage 任务</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">NSOperationQueue *operationQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">// 同一时间最多开启的线程数</span><br><span class="line">operationQueue.maxConcurrentOperationCount = 6;</span><br><span class="line">[operationQueue addOperation:blockOperation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)operationManage&#123;</span><br><span class="line">/*</span><br><span class="line">* 多任务队列添加依赖--串行执行</span><br><span class="line">* 一般多任务队列默认是并行执行，添加依赖可按依赖条件顺序执行</span><br><span class="line">*/</span><br><span class="line">NSBlockOperation *downloadImgPng = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">//downloadImage 任务</span><br><span class="line">NSLog(@&quot;png -- 当前线程%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">NSBlockOperation *downloadImgJpg = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">//downloadImage 任务</span><br><span class="line">NSLog(@&quot;jpg -- 当前线程%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">[downloadImgJpg addDependency:downloadImgPng];</span><br><span class="line"></span><br><span class="line">NSBlockOperation *downloadImgPdf = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">//downloadImage 任务</span><br><span class="line">NSLog(@&quot;pdf -- 当前线程%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">[downloadImgPdf addDependency:downloadImgJpg];</span><br><span class="line"></span><br><span class="line">NSOperationQueue *operationQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">// 同一时间最多开启的线程数</span><br><span class="line">operationQueue.maxConcurrentOperationCount = 6;</span><br><span class="line"></span><br><span class="line">[operationQueue addOperations:@[downloadImgPng,downloadImgJpg,downloadImgPdf] waitUntilFinished:NO];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![NSOperation对象执行状态.png](http://upload-images.jianshu.io/upload_images/308319-7ab06633c62b3faf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br></pre></td></tr></table></figure>
<p>/*<br>此属性指定应用于添加到队列中的操作对象的服务级别。如果操作对象具有显式的服务水平集，则使用该值。此属性的默认值取决于您创建队列的方式。自己创建的队列，默认值是NSOperationQualityOfServiceBackground。为队列的mainqueue方法返回，默认值是nsoperationqualityofserviceuserinteractive和不能改变的。</p>
<p>服务级别影响给定操作对象访问系统资源的优先级，如CPU时间、网络资源、磁盘资源等。具有较高服务质量级别的操作在系统资源上被赋予更大的优先权，以便它们能更快地执行任务。您使用服务级别确保响应显式用户请求的操作优先于不重要的工作。<br>*/<br>@property NSQualityOfService qualityOfService;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">typedef enum NSQualityOfService : NSInteger &#123;</span><br><span class="line">NSQualityOfServiceUserInteractive = 0x21,</span><br><span class="line">NSQualityOfServiceUserInitiated = 0x19,</span><br><span class="line">NSQualityOfServiceUtility = 0x11,</span><br><span class="line">NSQualityOfServiceBackground = 0x09,</span><br><span class="line">NSQualityOfServiceDefault = -1</span><br><span class="line">&#125; NSQualityOfService;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>NSQualityOfServiceUserInteractive</code> 用于直接提供交互式UI的工作。例如，处理控件事件或绘制到屏幕上。<br><code>NSQualityOfServiceUserInitiated</code> 用于执行用户明确要求的工作，必须立即提交结果，以便进一步进行用户交互。例如，在用户在邮件列表中选择邮件后，加载电子邮件。<br><code>NSQualityOfServiceUtility</code> 用于执行用户不太可能立即等待结果的工作。这项工作可能是用户要求的，也可能是自动启动的，并且经常使用非模态进度指示器在用户可见的时间尺度上运行。例如，周期性内容更新或大容量文件操作，如媒体导入。<br><code>NSQualityOfServiceBackground</code>用于非用户发起或可见的工作。一般来说，用户不知道这项工作甚至正在发生。例如，预取内容，搜索索引、备份或同步与外部系统的数据。<br><code>NSQualityOfServiceDefault</code>指示没有明确的服务质量信息。只要有可能，适当的服务质量由可用的来源决定。否则，选择的可能是<code>NSQualityOfServiceUserInteractive</code>和<code>NSQualityOfServiceUtility</code>之间服务水平的任意一种。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">此属性包含操作的相对优先级。这个值是用来影响其中的操作和执行顺序出列。</span><br><span class="line">官方建议：为了确定优先级，应该始终使用这些常量（而不是定义的值）。</span><br><span class="line">*/</span><br><span class="line">@property NSOperationQueuePriority queuePriority;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123;</span><br><span class="line">NSOperationQueuePriorityVeryLow = -8L,</span><br><span class="line">NSOperationQueuePriorityLow = -4L,</span><br><span class="line">NSOperationQueuePriorityNormal = 0,</span><br><span class="line">NSOperationQueuePriorityHigh = 4,</span><br><span class="line">NSOperationQueuePriorityVeryHigh = 8</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上两个属性通过设置合适的值，能让资源利用更加合理。其他的API可查看官方文档使用，特别注意的是<code>- (void)waitUntilFinished;</code>这个接口要慎用，该接口绝不能在主线程调用，会产生死锁卡死主线程。一般来讲用<code>- (void)addDependency:(NSOperation *)op;</code>依赖API就够了，简单易用。</p>
<p><code>- (void)waitUntilFinished;</code>接口的文档解释：</p>
<blockquote>
<p>An operation object must never call this method on itself and should avoid calling it on any operations submitted to the same operation queue as itself. Doing so can cause the operation to deadlock. Instead, other parts of your app may call this method as needed to prevent other tasks from completing until the target operation object finishes. It is generally safe to call this method on an operation that is in a different operation queue, although it is still possible to create deadlocks if each operation waits on the other.<br>A typical use for this method would be to call it from the code that created the operation in the first place. After submitting the operation to a queue, you would call this method to wait until that operation finished executing.</p>
<p>翻译：操作对象绝不能自己调用这个方法，应该避免在提交给同一操作队列的任何操作中调用它。这样做可能导致操作死锁。相反，应用程序的其他部分可以根据需要调用此方法，以防止其他任务完成，直到目标操作对象完成为止。一般来说，在不同的操作队列中调用这种方法是安全的，但如果每个操作都等待另一个操作，仍然有可能造成死锁。<br>这种方法的一个典型用途是首先从创建操作的代码调用它。在向队列提交操作之后，您将调用此方法等待该操作完成执行。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/308319-edc3a36a5087fb4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="waitUntilFinished简单使用.png"></p>
<h1 id="GCD的主要API使用"><a href="#GCD的主要API使用" class="headerlink" title="GCD的主要API使用"></a>GCD的主要API使用</h1><ul>
<li><h3 id="GCD的实现步骤"><a href="#GCD的实现步骤" class="headerlink" title="GCD的实现步骤"></a>GCD的实现步骤</h3>GCD实现多线程的步骤主要有2步：<br>1&gt;创建队列<br>2&gt;添加执行任务到队列中<br>也可以是1步，添加执行任务到系统标准队列<br>没错，就是这么简单易用！以下是代码片段：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 创建队列 ，手动创建的队列需要做释放处理，因为Dispatch Queue并没有被作为OC对象处理</span><br><span class="line">/*</span><br><span class="line">* 1.创建串行队列</span><br><span class="line">* 串行队列有两种创建方式</span><br><span class="line">*/</span><br><span class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.example.gcd.mytest&quot;, NULL);</span><br><span class="line">// 释放队列</span><br><span class="line">dispatch_release(serialQueue);</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd.mytest&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">// 释放队列</span><br><span class="line">dispatch_release(queue);</span><br><span class="line"></span><br><span class="line">// 2.创建并行队列</span><br><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.example.gcd.mytest&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">// 3.添加同步任务到队列中</span><br><span class="line">dispatch_sync(concurrentQueue, ^&#123;</span><br><span class="line">// 执行任务</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 4.添加异步任务到队列中</span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">// 执行任务</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 5.释放队列( iOS 6.0 or Mac OS X 10.8 以上系统可以管理GCD对象无需手动释放)</span><br><span class="line">dispatch_release(concurrentQueue);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 一步搞定</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">// 执行操作</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>GCD的队列主要有两种<code>Serial Dispatch Queue</code>和<code>Concurrent Dispatch Queue</code>。前者只有一个线程，后者根据任务量，可以开启多条线程。当然多个<code>Serial Dispatch Queue</code>是可以并行执行的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/308319-b48a0a22d2f7000d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两种队列和线程的关系.png"></p>
<ul>
<li><h3 id="Main-Dispatch-Queue-Global-Dispatch-Queue"><a href="#Main-Dispatch-Queue-Global-Dispatch-Queue" class="headerlink" title="Main Dispatch Queue / Global Dispatch Queue"></a>Main Dispatch Queue / Global Dispatch Queue</h3><code>Main Dispatch Queue</code>和<code>Global Dispatch Queue</code>是系统提供的标准<code>Dispatch Queue</code>，这两个标准队列还有一个共同的优点，那就是相比于手动创建的队列，这两个队列不需要开发者做队列释放的操作，因为这两个队列对应用程序而言是全局的，详细可查看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW5" target="_blank" rel="noopener">官方文档</a>。</li>
</ul>
<p><code>Main Dispatch Queue</code>可能你已经猜到了，没错，它就是主线程队列，追加到<code>Main Dispatch Queue</code>的处理在主线程的<code>RunLoop</code>中执行，一些需要更新UI界面的操作可以放到这个线程中执行。</p>
<p><code>Global Dispatch Queue</code>是<code>Concurrent Dispatch Queue</code>类型的队列。所以我们一般是不用逐个生成<code>Concurrent Dispatch Queue</code>队列的，只要使用全局队列<code>Global Dispatch Queue</code>就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 主队列</span><br><span class="line">dispatch_queue_t mainQueue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">// 全局队列</span><br><span class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br></pre></td></tr></table></figure>
<p>创建全局队列的API<code>dispatch_get_global_queue(long identifier, unsigned long flags);</code>需要传两个参数，第一个是优先级，根据实际处理内容选择合适的优先级。第二个官方文档称是为将来使用预留的，一般传数字0即可。<br><figure class="highlight plain"><figcaption><span>Dispatch Queue```有4个执行优先级。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">#define DISPATCH_QUEUE_PRIORITY_HIGH 2               // 高优先级</span><br><span class="line">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0            // 默认优先级</span><br><span class="line">#define DISPATCH_QUEUE_PRIORITY_LOW (-2)             // 低优先级</span><br><span class="line">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台优先级</span><br></pre></td></tr></table></figure></p>
<ul>
<li><h3 id="dispatch-sync-dispatch-asycn"><a href="#dispatch-sync-dispatch-asycn" class="headerlink" title="dispatch_sync / dispatch_asycn"></a>dispatch_sync / dispatch_asycn</h3><code>dispatch_asycn</code>是异步处理函数，该函数不会等待任务执行完，不会一直占用当前线程。</li>
</ul>
<p><code>dispatch_sync</code>是同步处理函数，在该函数中执行的任务不执行完，该函数会一直在当前线程等待。也可以说这个函数是简化版的<code>dispatch_group_wait</code>函数。</p>
<p><code>dispatch_sync</code>要慎用，因为使用不当就会引起死锁。<br>比如在主线程调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t mianQueue = dispatch_get_main_queue();</span><br><span class="line">dispatch_async(mainQueue, ^&#123;</span><br><span class="line">dispatch_sync(mainQueue, ^&#123;</span><br><span class="line">NSLog(@&quot;Hello World&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在<code>Serial Diapatch Queue</code>中调用也是一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd.mytest&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">NSLog(@&quot;Hello World&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>死锁的原因很明显就是两个操作在同一个线程里互相等待对方执行完，一直互相等待，谁也不执行。</p>
<ul>
<li><h3 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h3>手动创建的队列可以通过<code>dispatch_set_target_queue</code>设定执行的优先级。将<code>Dispatch Queue</code>指定为<code>dispatch_set_target_queue</code>的函数参数，不仅可以变更<code>Dispatch Queue</code>的执行优先级，还可以作为执行阶层。</li>
</ul>
<p>比如，将一个普通的<code>Serial Diapatch Queue</code>设定为与“后台优先级全局队列”一样的优先级和阶层，那么在执行时，它的执行优先级将高于其他普通的<code>Serial Diapatch Queue</code>和<code>Concunrrent Diapatch Queue</code>，它的阶层也要比普通的<code>Serial Diapatch Queue</code>和<code>Concunrrent Diapatch Queue</code>高，当它与“后台优先级全局队列”阶层一样时意味着，如果它在执行，其他普通的<code>Serial Diapatch Queue</code>和<code>Concunrrent Diapatch Queue</code>都不能和它并行执行，必须等它执行完才能执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建串行队列</span><br><span class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.example.gcd.mytest&quot;, NULL);</span><br><span class="line"></span><br><span class="line">// 创建并行队列</span><br><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.example.gcd.mytest&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* 参照serialQueue的优先级设置目标队列 即concurrentQueue的优先级</span><br><span class="line">* 第一个参数为要设置优先级的queue,第二个参数是参照物，既将第一个queue的优先级和第二个queue的优先级设置一样。</span><br><span class="line">*/</span><br><span class="line">dispatch_set_target_queue(concurrentQueue, serialQueue);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><h3 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h3><code>dispatch_after</code>用于延时处理，需要注意的是并不是<code>dispatch_after</code>在延时指定时间后执行，而是在指定时间把任务添加到队列中，相当于加了一个计时器，时间到了就把任务添加到队列中了。</li>
</ul>
<p>栗子：<br>延时3秒打印Hello Word<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3ull*NSEC_PER_SEC);</span><br><span class="line">dispatch_after(time, dispatch_get_main_queue(), ^&#123;NSLog(@&quot;Hello World&quot;);&#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>dispatch_time</code>的第一个参数是起始时间可传：<code>DISPATCH_TIME_NOW</code>和 <code>DISPATCH_TIME_FOREVER</code>。<br><code>DISPATCH_TIME_NOW</code> : 表示从现在开始 <code>DISPATCH_TIME_FOREVER</code>：表示持续等待，稍后会用到。<br>第二个参数是秩序多久，<code>&quot;ull&quot;</code>是C语言的数值字面量，是显示表明类型时使用的字符串（表示”unsight long long”）为了精确时间写上<code>&quot;ull&quot;</code>。<code>NSEC_PER_SEC</code>是秒时间单位的一种，表示纳秒级精确的一秒。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define NSEC_PER_SEC 1000000000ull  // 每秒有多少纳秒</span><br><span class="line">#define NSEC_PER_MSEC 1000000ull    // 每毫秒有多少纳秒</span><br><span class="line">#define USEC_PER_SEC 1000000ull     // 每秒有多少毫秒</span><br><span class="line">#define NSEC_PER_USEC 1000ull       // 每微秒有多少毫秒</span><br></pre></td></tr></table></figure></p>
<ul>
<li><h3 id="Dispatch-Group"><a href="#Dispatch-Group" class="headerlink" title="Dispatch Group"></a>Dispatch Group</h3>有时我们想等添加到队列中的所有任务都执行完再执行结束处理。<code>Serial Dispatch Queue</code>好说，本来就是串行的。但是<code>Concurrent Dispatch Queue</code>就不行了，异步的我们根本不知道哪个是最后执行完的。这个时候就可以用到<code>Dispatch Group</code>了。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;block 0&quot;);&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;block 1&quot;);&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;block 2&quot;);&#125;);</span><br><span class="line">/*</span><br><span class="line">* 无论向什么样的Dispatch Queue中添加任务，使用Dispatch Group都可以监听这个任务的执行结束</span><br><span class="line">* 所有任务结束时，会执行dispatch_group_notify函数的block</span><br><span class="line">*/</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;NSLog(@&quot;done&quot;);&#125;);</span><br><span class="line"></span><br><span class="line">// iOS 6.0 or Mac OS X 10.8 以上系统可以管理GCD对象无需手动释放</span><br><span class="line">dispatch_release(group);</span><br></pre></td></tr></table></figure>
<p>用<code>dispatch_group_wait</code>也可以达到同样的效果，不过前者更简洁，所以建议用<code>dispatch_group_notify</code>，下边是<code>dispatch_group_wait</code>的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;block 0&quot;);&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;block 1&quot;);&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;block 2&quot;);&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_FOREVER, 1ull*NSEC_PER_SEC);</span><br><span class="line">long result = dispatch_group_wait(group, time);</span><br><span class="line">/*</span><br><span class="line">指定DISPATCH_TIME_NOW，则不用任何等待，即可判断Dispatch Group中的处理是否执行结束</span><br><span class="line">（在主线程的Runloop的每次循环中可检查执行是否结束，从而不耗费多余的等待时间）</span><br><span class="line">*/</span><br><span class="line">// long result = dispatch_group_wait(group, DISPATCH_TIME_NOW);</span><br><span class="line"></span><br><span class="line">if (result == 0) &#123;</span><br><span class="line">// group的全部任务执行完毕</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// group的某个任务还在执行中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// iOS 6.0 or Mac OS X 10.8 以上系统可以管理GCD对象无需手动释放</span><br><span class="line">// dispatch_release(group);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><h3 id="Dispatch-Semaphore-信号量"><a href="#Dispatch-Semaphore-信号量" class="headerlink" title="Dispatch Semaphore 信号量"></a>Dispatch Semaphore 信号量</h3>GCD信号量的用法主要有两种，一种是监听1个异步执行结果，另外一种是控制线程并发数。<br>信号量的函数有3个：</li>
</ul>
<ol>
<li>创建信号量，传入的value要大于等于0<br><code>dispatch_semaphore_create(long value);</code></li>
<li>增加一个信号量<br><code>dispatch_semaphore_signal(dispatch_semaphore_t dsema);</code></li>
<li>减少1个信号量，并且信号量为0则等待，等待时间取决于<code>timeout</code>时间参数<br><code>dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);</code></li>
</ol>
<p>接下来看代码：</p>
<ul>
<li><p>信号量监听1个异步执行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);// 信号量为0</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">NSLog(@&quot;run task 1&quot;);</span><br><span class="line">sleep(1);</span><br><span class="line">NSLog(@&quot;complete task 1&quot;);</span><br><span class="line">// 信号量+1</span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 若信号量为0则一直等待</span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">NSLog(@&quot;继续执行函数&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017-12-19 11:35:31.731268+0800 多线程[3482:317136] run task 1</span><br><span class="line">2017-12-19 11:35:32.736671+0800 多线程[3482:317136] complete task 1</span><br><span class="line">2017-12-19 11:35:32.737201+0800 多线程[3482:316871] 继续执行函数</span><br></pre></td></tr></table></figure>
</li>
<li><p>信号量控制线程数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 信号量为2，相当于线程最大并发数为2</span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(2);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">// 若信号量为0则一直等待，不为0则信号量-1并继续执行函数</span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">NSLog(@&quot;run task 1&quot;);</span><br><span class="line">sleep(1);</span><br><span class="line">NSLog(@&quot;complete task 1&quot;);</span><br><span class="line">dispatch_semaphore_signal(semaphore); // 信号量+1</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">NSLog(@&quot;run task 2&quot;);</span><br><span class="line">sleep(1);</span><br><span class="line">NSLog(@&quot;complete task 2&quot;);</span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">NSLog(@&quot;run task 3&quot;);</span><br><span class="line">sleep(1);</span><br><span class="line">NSLog(@&quot;complete task 3&quot;);</span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">1.信号量初始值为2（即线程最大并发数为2）；</span><br><span class="line">2.任务1执行信号量-1，任务2执行信号量-1，此时信号量为0（即两个线程已经有任务在执行，任务3只能等待）；</span><br><span class="line">3.当任务1或任务2执行完，则信号量+1，信号量不为0（即有一个可用线程，此时任务3可执行）。</span><br><span class="line">*/</span><br><span class="line">2017-12-19 11:41:28.631848+0800 多线程[3542:324794] run task 2</span><br><span class="line">2017-12-19 11:41:28.631849+0800 多线程[3542:324796] run task 1</span><br><span class="line">2017-12-19 11:41:29.636731+0800 多线程[3542:324794] complete task 2</span><br><span class="line">2017-12-19 11:41:29.636758+0800 多线程[3542:324796] complete task 1</span><br><span class="line">2017-12-19 11:41:29.637094+0800 多线程[3542:324795] run task 3</span><br><span class="line">2017-12-19 11:41:30.637980+0800 多线程[3542:324795] complete task 3</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://www.cnblogs.com/zhouxihi/p/6296485.html" target="_blank" rel="noopener">关于信号量和Dispatch Group异步线程的延伸阅读</a></p>
<ul>
<li><h3 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h3><code>dispatch_once</code>大家比较熟，因为线程安全的单例模式常用到它。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+(instancetype)sharedSingleton&#123;</span><br><span class="line">static id instance = nil;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">instance = [[self alloc] init];</span><br><span class="line">&#125;);</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>还可以用<code>@synchronized()</code>这个互斥锁实现单例模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+(instancetype)sharedSingleton&#123;</span><br><span class="line">static id instance = nil;</span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">if (!instance) &#123;</span><br><span class="line">instance = [[self alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><h3 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h3><p>在访问数据库或文件时，为避免数据竞争，前面讲到可以使用<code>Serial Dispatch Queue</code>。但是其实如果是读取和读取并行执行是不会引起数据竞争的，如果能把这部分操作拆分出来，那无疑会提高访问效率。<code>dispatch_barrier_async</code>配合手动创建的<code>Concurrent Dispatch Queue</code>就可以帮我们做到。在执行<code>dispatch_barrier_async</code>时，它会等正在执行的任务执行完开始，当它结束后其他任务才会再开始执行。在SDWebImage框架中也有用到它和它的同步函数<code>dispatch_barrier_sync</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd.mytest&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">// 执行读取操作</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">// 执行读取操作</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">// 执行写入操作</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">// 执行读取操作</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">// 执行读取操作</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="dispatch-suspend-dospatch-resume"><a href="#dispatch-suspend-dospatch-resume" class="headerlink" title="dispatch_suspend / dospatch_resume"></a>dispatch_suspend / dospatch_resume</h3><p>在队列大量任务执行时，需要临时挂起队列时调用<code>dispatch_suspend</code><br><code>dispatch_suspend(queue)</code>挂起队列<br><code>dospatch_resume (queue)</code>恢复队列</p>
</li>
</ul>
<p>GCD还提供可多线程读取同一个大型文件的API<code>dispatch I/O</code>和<code>dispatch Data</code>,还有其他很多有意思有用的API，大家尽可以去查看官方文档学习和使用。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>苹果官方文档</li>
<li>《现代操作系统》</li>
<li>《Objective-C高级编程- iOS与OS X多线程和内存管理》</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS开发/" rel="tag"># iOS开发</a>
          
            <a href="/tags/多线程/" rel="tag"># 多线程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/21/iOS开发-iWatch通知中心快捷回复实现/" rel="next" title="iOS开发-iWatch通知中心快捷回复实现">
                <i class="fa fa-chevron-left"></i> iOS开发-iWatch通知中心快捷回复实现
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/09/iOS开发-自动化打包Jenkins集成/" rel="prev" title="iOS开发-自动化打包Jenkins集成">
                iOS开发-自动化打包Jenkins集成 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/assets/img/icon.png"
               alt="ZhiWei" />
          <p class="site-author-name" itemprop="name">ZhiWei</p>
           
              <p class="site-description motion-element" itemprop="description">记录与分享</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#iOS多线程开发必须知道的概念名词："><span class="nav-number">1.</span> <span class="nav-text">iOS多线程开发必须知道的概念名词：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-进程"><span class="nav-number">2.</span> <span class="nav-text">1. 进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-线程"><span class="nav-number">3.</span> <span class="nav-text">2. 线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程和线程的关系"><span class="nav-number">4.</span> <span class="nav-text">进程和线程的关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-串行（serial）-amp-并发（concurrent）-amp-并行"><span class="nav-number">5.</span> <span class="nav-text">3.  串行（serial） &amp;  并发（concurrent）&amp; 并行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-同步-amp-异步"><span class="nav-number">6.</span> <span class="nav-text">4. 同步 &amp; 异步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-调度队列（Dispatch-Queue）"><span class="nav-number">7.</span> <span class="nav-text">5. 调度队列（Dispatch Queue）</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#iOS多线程技术对比"><span class="nav-number"></span> <span class="nav-text">iOS多线程技术对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread"><span class="nav-number"></span> <span class="nav-text">pthread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSThread"><span class="nav-number"></span> <span class="nav-text">NSThread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSOperation"><span class="nav-number"></span> <span class="nav-text">NSOperation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD"><span class="nav-number"></span> <span class="nav-text">GCD</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NSOperation-1"><span class="nav-number"></span> <span class="nav-text">NSOperation</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GCD的主要API使用"><span class="nav-number"></span> <span class="nav-text">GCD的主要API使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD的实现步骤"><span class="nav-number"></span> <span class="nav-text">GCD的实现步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Main-Dispatch-Queue-Global-Dispatch-Queue"><span class="nav-number"></span> <span class="nav-text">Main Dispatch Queue / Global Dispatch Queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-sync-dispatch-asycn"><span class="nav-number"></span> <span class="nav-text">dispatch_sync / dispatch_asycn</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-set-target-queue"><span class="nav-number"></span> <span class="nav-text">dispatch_set_target_queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-after"><span class="nav-number"></span> <span class="nav-text">dispatch_after</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dispatch-Group"><span class="nav-number"></span> <span class="nav-text">Dispatch Group</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dispatch-Semaphore-信号量"><span class="nav-number"></span> <span class="nav-text">Dispatch Semaphore 信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-once"><span class="nav-number"></span> <span class="nav-text">dispatch_once</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-barrier-async"><span class="nav-number"></span> <span class="nav-text">dispatch_barrier_async</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-suspend-dospatch-resume"><span class="nav-number"></span> <span class="nav-text">dispatch_suspend / dospatch_resume</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number"></span> <span class="nav-text">参考</span></a></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear"> 2018</span>

  <span class="author" itemprop="copyrightHolder">ZhiWei</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
